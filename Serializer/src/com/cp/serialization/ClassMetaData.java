package com.cp.serialization;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


class ClassMetaData {
	private static final long serialVersionUID = -7188760550856725826L;
	
	private final List<FieldInfo> fields = new ArrayList<FieldInfo>();
	private final String key;
	private final String className;
	
	/**
	 * Identifier used to reference this metadata when a class
	 * of its type is serialized
	 */
	private Long compactId;
	
	/**
	 * Creates an instance of the class MetaData based on the
	 * supplied class.  Can throw an IllegalStateException if
	 * the system does not support UTF-8 or SHA-1
	 */
	public ClassMetaData(Class<?> clazz) {
		try {
			for(Field field : clazz.getDeclaredFields()) {
				boolean skipField = false;
				skipField |= Modifier.isStatic(field.getModifiers());
				skipField |= Modifier.isFinal(field.getModifiers());
				skipField |= Modifier.isTransient(field.getModifiers());
				if(!skipField) {
					fields.add(new FieldInfo(field.getName(), field.getType().getName()));
				}
			}
			
			// sort the fields so they appear in alphabetical order
			Collections.sort(fields);
			MessageDigest md = MessageDigest.getInstance("SHA-1");
			for(FieldInfo field : fields) {
				md.update(field.getName().getBytes("UTF-8"));
				md.update(field.getClassName().getBytes("UTF-8"));
			}
			
			key = clazz.getName() + "/" + bytesToHex(md.digest());
			className = clazz.getName();
		} catch (UnsupportedEncodingException e) {
			throw new IllegalStateException(e);
		} catch (NoSuchAlgorithmException e) {
			throw new IllegalStateException(e);
		}
	}
	
	/**
	 * Rebuids the class metadata from data generated by its
	 * {@link #toByteArray()} method
	 */
	public ClassMetaData(String key, byte[] data) throws IOException {
		this.key = key;
		this.className = key.substring(0, key.indexOf('/'));
		DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data));
		
		this.compactId = dis.readLong();
		long fieldCount = dis.readInt();
		for(int i = 0; i < fieldCount; i++) {
			String fieldName = dis.readUTF();
			String className = dis.readUTF();
			fields.add(new FieldInfo(fieldName, className));
		}
		
		Collections.sort(fields);
	}
	
	public Long getCompactId() {
		return compactId;
	}
	
	public byte[] toByteArray() {
		if(compactId == null) {
			throw new IllegalStateException("compactId must be set before calling toByteArray()");
		}
		
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			DataOutputStream dos = new DataOutputStream(baos);
			dos.writeLong(compactId);
			dos.writeInt(fields.size());
			for(FieldInfo fieldInfo : fields) {
				dos.writeUTF(fieldInfo.getName());
				dos.writeUTF(fieldInfo.getClassName());
			}
			
			return baos.toByteArray();
		} catch (IOException e) {
			throw new IllegalStateException("ByteArrayOuputStream should not throw IOException");
		}
	}
	
	public String getKey() {
		return key;
	}
	
	public String getClassName() {
		return className;
	}
	
	public List<FieldInfo> getFields() {
		return fields;
	}
	
	protected void setCompactId(long compactId) {
		this.compactId = compactId;
	}
	
	private static String bytesToHex(byte[] bytes) {
		StringBuilder hexString = new StringBuilder();
		for(byte b : bytes) {
			String hex = Integer.toString(b&0xFF, 16);
			if(hex.length() < 2) {
				hexString.append("0");
			}
			hexString.append(hex);
		}
		return hexString.toString();
	}
	
	/**
	 * Used to store the name and type of a Field and
	 * to allow such information to be sorted
	 * alphabetically by field name
	 */
	static class FieldInfo implements Comparable<FieldInfo> {
		private final String name;
		private final String className;
		
		public FieldInfo(String name, String className) {
			this.name = name;
			this.className = className;
		}
		
		public String getName() {
			return name;
		}
		
		public String getClassName() {
			return className;
		}
		
		@Override
		public int compareTo(FieldInfo o) {
			return name.compareTo(o.getName());
		}
	}
}
